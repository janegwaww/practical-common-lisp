

# exercise-12

1.  [Draw three different trees that&#x2026;](#org18822ad)
2.  [Assuming make-queue,&#x2026;](#org4436098)
3.  [Define a function `copy-queue` that returns a copy of a queue.](#org8f14ace)
4.  [Define a function that&#x2026;](#org247a21e)
5.  [Define a function that&#x2026;](#orgf989909)
6.  [Define a function that&#x2026;](#org9d09ca4)
7.  [Define a function that&#x2026;](#org62f6407)
8.  [Define a function that&#x2026;](#org6d55dd8)


<a id="org18822ad"></a>

## Draw three different trees that&#x2026;

1.Draw three different trees that would print as ((A) (A) (A)). Write an expression that generates each.

    (cons (cons 'a nil) (cons (cons 'a nil) (cons (cons 'a nil) nil)))
    
    (make-array '(3 1) :initial-element 'a)
    
    (vector '(a) '(a) '(a))


<a id="org4436098"></a>

## Assuming make-queue,&#x2026;

2.Assuming `make-queue`, `enqueue`, and `dequeue` are defined as in Figure 12.7, draw the queue in box-notation after each step:

    (defun make--queue () (cons nil nil))
    
    (defun enqueue (obj q)
      (if (null (car q))
          (setf (cdr q) (setf (car q) (list obj)))
          (setf (cdr (cdr q)) (list obj)
                (cdr q) (cdr (cdr q))))
      (car q))
    
    (defun dequeue (q)
      (pop (car q)))

    ;;> (setf q (make-queue)) ==> (NIL)

<!-- This HTML table template is generated by emacs 28.2 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      nil
    </td>
    <td align="left" valign="top">
      nil
    </td>
  </tr>
</table>

    ;;> (enqueue 'a q) ==> (A)

<!-- This HTML table template is generated by emacs 28.2 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

    ;;> (enqueue 'b q) ==> (A B)

<del>---</del>&#x2014;+

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<del>-</del>-<del>-</del>-+

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
</tr>


<tr>
<td class="org-left"><del>---------</del></td>
</tr>
</tbody>
</table>

<del>-</del>-<del>----</del>  <del>---</del>&#x2014;+

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-left"><del>--</del> b</td>
<td class="org-left">nil</td>
</tr>
</tbody>
</table>

<del>---</del>-&#x2014;+  <del>---</del>&#x2014;+

    ;;> (dequeue q) ==> A

<!-- This HTML table template is generated by emacs 28.2 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;a&nbsp;
    </td>
  </tr>
</table>


<a id="org8f14ace"></a>

## Define a function `copy-queue` that returns a copy of a queue.

    (defun copy-queue (q)
      (if (null (car q))
          nil
          (list (cons (car (car q))
                      (copy-queue  (list (cdr (car q)) (cdr q))))
                (cdr q))))


<a id="org247a21e"></a>

## Define a function that&#x2026;

4.Define a function that takes an object and a queue, and puts the object on the *front* of the queue.

    (defun push-queue (obj q)
      (setf (car q) (push obj (car q))))


<a id="orgf989909"></a>

## TODO Define a function that&#x2026;

5.Define a function that takes an object and a queue, and (destructively) moves the first (`eql`) instance of the object to the front of the queue.

    (defun push-first-queue (obj q)
      (push-queue obj q))


<a id="org9d09ca4"></a>

## Define a function that&#x2026;

6.Define a function that takes an object and a possibly cdr-circular list, and returns true if the object is a member of the list.

    (defun cdr-circle-m (obj cc)
      (if (cdr-circle-p cc)
          (member obj cc)
          nil))


<a id="org62f6407"></a>

## Define a function that&#x2026;

7.Define a function that returns true when its argument is a cdr-circular list.

    (defun cdr-circle-p (c)
      (and
        (consp c)
        (eql (cdr c) c)))


<a id="org6d55dd8"></a>

## Define a function that&#x2026;

8.Define a function that returns true when its argument is a car-circular list.

